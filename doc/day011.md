# 第十天 并发编程和异步编程（1）

今天计划学习Python的多线程编程异步编程，学习项目及练习源码地址：
[GitHub源码](https://github.com/coojee2012/LearnPython)

## 线程

线程也是实现多任务的一种方式，一个进程中，也经常需要同时做多件事，就需要同时运行多个‘子任务’，这些子任务就是线程。一个进程可以拥有多个并行的线程，其中每一个线程，共享当前进程的资源。

再巩固下进程和线程的区别：

|区别 |	进程 |	线程|
| -----|-----|-----|
根本区别	| 作为资源分配的单位 |	调度和执行的单位
开销	|每一个进程都有独立的代码和数据空间，进程间的切换会有较大的开销	|线程可以看出是轻量级的进程，多个线程共享内存，线程切换的开销小
所处环境 |	在操作系统中，同时运行的多个任务 |	在程序中多个顺序流同时执行
分配内存	| 系统在运行的时候为每一个进程分配不同的内存区域 |	线程所使用的资源是他所属进程的资源
包含关系	| 一个进程内可以拥有多个线程	| 线程是进程的一部分，所有线程有时候称为是轻量级的进程

进程和线程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护，而进程正相反。

在Python3程序中，可以通过_thread(兼容python2,不建议使用)和threading（推荐使用）这两个模块来处理线程。

### _thread模块
可以通过两种方式来使用线程：使用函数或者使用类来包装线程对象。当使用_thread模块来处理线程时，可以调用里面的函数start_new_thread()来生成一个新的线程，语法格式如下:

```thread.start_new_thread ( function, args[, kwargs] )```

其中function是线程函数；args表示传递给线程函数的参数，他必须是个tuple(元祖)类型；kwargs是可选参数。

【示例】使用_thread模块创建线程：

```python
import _thread
import time
def fun1():
    print('开始运行fun1')
    time.sleep(4)
    print('运行fun1结束')
def fun2():
    print('开始运行fun2')
    time.sleep(2)
    print('运行fun2结束')
if __name__=='__main__':
    print('开始运行')
    #启动一个线程运行函数fun1
    _thread.start_new_thread(fun1,())
     #启动一个线程运行函数fun2
    _thread.start_new_thread(fun2,())
    time.sleep(6)
'''
开始运行
开始运行fun1
开始运行fun2
运行fun2结束
运行fun1结束
'''
```
### threading模块
Python3 通过两个标准库_thread和threading提供对线程的支持。_thread提供了低级别的、原始的线程以及一个简单的锁，它相比于threading模块的功能还是比较有限的。threading模块除了包含 _thread模块中的所有方法外，还提供的其他方法：


1. threading.currentThread(): 返回当前的线程变量。
2. threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
3. threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。
4. 
在Python3程序中，对多线程支持最好的是threading模块，使用这个模块，可以灵活地创建多线程程序，并且可以在多线程之间进行同步和通信。在Python3程序中，可以通过如下两种方式来创建线程：

1. 通过threading.Thread直接在线程中运行函数
2. 通过继承类threading.Thread来创建线程
   
在Python中使用threading.Thread的基本语法格式如下所示：

```Thread(group=None, target=None, name=None, args=(), kwargs={})```

其中target: 要执行的方法；name: 线程名；args/kwargs: 要传入方法的参数。

Thread类的方法如表所示：

方法名	| 描述
|-----|-----|

run()	| 用以表示线程活动的方法
start() |	启动线程活动
join([time]) |	等待至线程中止。这阻塞调用线程直至线程的join()方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生
isAlive()	| 返回线程是否活动的
getName()	 | 返回线程名
setName()	| 设置线程名

【示例】threading.Thread直接创建线程：
```python
import threading
import time
def fun1(thread_name,delay):
    print('线程{0}开始运行fun1'.format(thread_name))
    time.sleep(delay)
    print('线程{0}运行fun1结束'.format(thread_name))
def fun2(thread_name,delay):
    print('线程{0}开始运行fun2'.format(thread_name))
    time.sleep(delay)
    print('线程{0}运行fun2结束'.format(thread_name))
if __name__=='__main__':
    print('开始运行')
    #创建线程
    t1=threading.Thread(target=fun1,args=('thread-1',2))
    t2=threading.Thread(target=fun2,args=('thread-2',4))
    t1.start()
    t2.start()
```
在Python中，通过继承类threading.Thread的方式来创建一个线程。这种方法只要重写类threading.Thread中的方法run()，然后再调用方法start()就能创建线程，并运行方法run()中的代码。

在调用Thread类的构造方法时，需要将线程函数、参数等值传入构造方法，其中name表示线程的名字，如果不指定这个参数，默认的线程名字格式为Thread-1、Thread-2。每一个传入构造方法的参数值，在Thread类中都有对应的成员变量保存这些值，这些成员变量都以下划线(_)开头，如果_target、_args等。在run方法中需要使用这些变量调用传入的线程函数，并为线程函数传递参数。

【示例】继承threading.Thread类创建线程:

```python
import threading
import time
def fun1(delay):
    print('线程{0}开始运行fun1'.format(threading.current_thread().getName()))
    time.sleep(delay)
    print('线程{0}运行fun1结束'.format(threading.current_thread().getName()))
def fun2(delay):
    print('线程{0}开始运行fun2'.format(threading.current_thread().getName()))
    time.sleep(2)
    print('线程{0}运行fun2结束'.format(threading.current_thread().getName()))
#创建线程类继承threading.Thread
class MyThread(threading.Thread):
    #重写父类的构造方法，其中func是线程函数，args是传入线程的参数,name是线程名
    def __init__(self,func,name,args):
        super().__init__(target=func,name=name,args=args)
    #重写父类的run()方法
    def run(self):
        self._target(*self._args)

if __name__=='__main__':
    print('开始运行')
    #创建线程
    t1=MyThread(fun1,'thread-1',(2,))
    t2=MyThread(fun2,'thread-2',(4,))
    t1.start()
    t2.start()
```

### 线程共享全局变量
在一个进程内所有线程共享全局变量，多线程之间的数据共享比多进程要好。但是可能造成多个进程同时修改一个变量（**即线程非安全**），可能造成混乱。

【示例】线程共享全局变量：

```python
import time
from threading import *
#定义全局变量num
num=10
def test1():
    global num
    for i in range(3):
        num+=1
    print('test1输出num:',num)

def test2():
    global num
    print('test2输出num:',num)

if __name__=='__main__':
    t1=Thread(target=test1)
    t2=Thread(target=test2)
    t1.start()
    t1.join() # 等待线程1结束才开始线程2
    t2.start()
    t2.join()
'''
test1输出num: 13
test2输出num: 13
'''
```

【示例】线程共享全局变量存在问题：
```python
import time
from threading import *
#定义全局变量num
num=0
def test1():
    global num
    for i in range(100000):
        num+=1
    print('test1输出num:',num)

def test2():
    global num
    for i in range(100000):
        num+=1
    print('test2输出num:',num)

if __name__=='__main__':
    t1=Thread(target=test1)
    t2=Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
'''
test1输出num: 176838
test2输出num: 181299 
每次结果都可能不一样，所以同一个进程中对共享变量的读取修改是不安全的。
'''
```

### 互斥锁
如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。最简单的同步机制就是引入互斥锁。

**锁有两种状态——锁定和未锁定。**某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”状态，其他的线程才能再次锁定该资源。

互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。
使用Thread对象的Lock可以实现简单的线程同步，有上锁acquire方法和释放release方法，**对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire和release方法之间。**

【示例】互斥锁：

```python
import time
from threading import Thread,Lock
#定义全局变量num
num=0
#创建一把互斥锁
mutex=Lock()
def test1():
    global num
    '''
    在两个线程中都调用上锁的方法，则这两个线程就会抢着上锁，
    如果有1方成功上锁，那么导致另外一方会堵塞（一直等待）直到这个锁被解开
    '''
    mutex.acquire()#上锁
    for i in range(100000):
        num+=1
    mutex.release()
    print('test1输出num:',num)

def test2():
    global num
    mutex.acquire()  # 上锁
    for i in range(100000):
        num+=1
    mutex.release()
    print('test2输出num:',num)

if __name__=='__main__':
    t1=Thread(target=test1)
    t2=Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

```

### 死锁
在线程共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。当一个线程永远地持有一个锁，并且其他线程都尝试去获得这个锁时，那么它们将永远被阻塞，这个我们都知道。如果线程A持有锁L并且想获得锁M，线程B持有锁M并且想获得锁L，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式。


### 避免死锁的方式

既然可能产生死锁，那么接下来，讲一下如何避免死锁。

1. 让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实

2. 设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量

3. 既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息